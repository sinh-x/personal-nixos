{
  # Snowfall Lib provides a customized `lib` instance with access to your flake's library
  # as well as the libraries available from your flake's inputs.
  lib,
  # An instance of `pkgs` with your overlays and packages applied is also available.
  pkgs,
  # You also have access to your flake's inputs.
  # All other arguments come from the module system.
  config,
  namespace,
  ...
}:
with lib;
let
  cfg = config.${namespace}.wm.bspwm;

  # Nix-interpolated values for scripts (use "auto" to indicate runtime detection)
  primaryMonitor = if cfg.monitors.primary != null then cfg.monitors.primary else "auto";
  inherit (cfg.monitors) externalPosition externalMaxResolution;
  inherit (cfg.workspaces) distribution;

  # Generated script: monitor-management.fish
  monitorManagementScript = ''
    #!/usr/bin/env fish

    # Auto-generated by Nix - do not edit manually
    # Priority: Nix config > auto-detect

    # Nix-interpolated values
    set NIX_PRIMARY_MONITOR "${primaryMonitor}"
    set EXTERNAL_POSITION "${externalPosition}"
    set EXT_MAX_RES ${toString externalMaxResolution}
    set DISTRIBUTION "${distribution}"

    # Resolve primary monitor: Nix config > auto-detect
    if test "$NIX_PRIMARY_MONITOR" != "auto"
        set INTERNAL_MONITOR "$NIX_PRIMARY_MONITOR"
    else
        # Auto-detect first connected monitor (usually internal)
        set INTERNAL_MONITOR (xrandr | grep " connected " | head -1 | awk '{print $1}')
    end

    # Main monitor position (left or right side of the display setup)
    set main_monitor_post $EXTERNAL_POSITION

    function set_display
        # Get the output of xrandr and split it into lines
        set output (xrandr | string split '\n')
        set index 0
        set connected_indices
        set disconnected_indices

        # Loop over the lines
        for line in $output
            set index (math $index+1)
            if string match -q "* connected *" $line
                set connected_indices $connected_indices $index
            else if string match -q "* disconnected *" $line
                set disconnected_indices $disconnected_indices $index
            end
        end

        set connected_monitors
        set resolutions

        # Loop over the indices of connected monitors to get their name & resolution
        for idx in $connected_indices
            set monitor_name (echo $output[$idx] | awk '{print $1}')
            set resolution_idx (math $idx+1)
            set res (echo $output[$resolution_idx] | awk '{print $1}')
            set width (echo $res | awk -F x '{print $1}')

            # If external monitor width exceeds max, use secondary resolution
            if test "$monitor_name" != "$INTERNAL_MONITOR" -a $width -gt $EXT_MAX_RES
                set resolution_idx (math $resolution_idx+1)
                set res (echo $output[$resolution_idx] | awk '{print $1}')
            end

            set connected_monitors $connected_monitors $monitor_name
            set resolutions $resolutions $res
        end

        # Turn off disconnected monitors
        for idx in $disconnected_indices
            set monitor_name (echo $output[$idx] | awk '{print $1}')
            xrandr --output $monitor_name --off 2>/dev/null
        end

        # Configure connected monitors with proper positioning
        set y 0
        set cur_x 0
        for i in (seq (count $connected_monitors))
            xrandr --output $connected_monitors[$i] --mode $resolutions[$i] --pos "$cur_x"x"$y"

            # Calculate x-coordinate for next monitor based on position preference
            if test "$main_monitor_post" = "left"
                set x_add (echo $resolutions[$i] | awk -F x '{print $1}')
                set cur_x (math $cur_x+$x_add)
            else
                set x_add (echo $resolutions[$i] | awk -F x '{print $1}')
                set cur_x (math $cur_x-$x_add)
            end
        end
    end

    function default_workspace
        # Single monitor: assign workspaces 1-10
        bspc monitor $INTERNAL_MONITOR -d 1 2 3 4 5 6 7 8 9 10
    end

    function two_monitors_workspace
        # Dual monitor workspace assignment based on distribution strategy
        for monitor in (bspc query -M --names)
            # Get the coordinates of the monitor
            set coordinate (xrandr | grep $monitor | grep -oP '\d+x\d+\+\d+\+\d+')
            set x_coordinate (echo $coordinate | awk -F '[x+]' '{print $3}')

            if test -n "$x_coordinate"
                set x_coordinate (math $x_coordinate)

                if test "$DISTRIBUTION" = "split"
                    # Split distribution: Left gets 1-5,11-15; Right gets 6-10,16-20
                    if test $x_coordinate -eq 0
                        bspc monitor $monitor -d 1 2 3 4 5 11 12 13 14 15
                    else
                        bspc monitor $monitor -d 6 7 8 9 10 16 17 18 19 20
                    end
                else
                    # primary-all distribution: Primary gets 1-10; External gets 11-20
                    if test "$monitor" = "$INTERNAL_MONITOR"
                        bspc monitor $monitor -d 1 2 3 4 5 6 7 8 9 10
                    else
                        bspc monitor $monitor -d 11 12 13 14 15 16 17 18 19 20
                    end
                end
            end
        end
    end

    # Configure displays
    set_display

    # Get the number of connected monitors
    set monitors_count (xrandr | grep -c " connected ")

    # Assign workspaces based on monitor count
    if test $monitors_count -eq 1
        default_workspace
    else
        two_monitors_workspace
    end
  '';

  # Filter to exclude the generated script from static copy
  bspwmConfigFilter =
    path: _:
    let
      baseName = baseNameOf path;
      pathStr = toString path;
    in
    !(
      # Exclude generated monitor-management script
      baseName == "monitor-management.fish"
      # Exclude host-specific monitor scripts (now generated)
      || (lib.hasInfix "monitors-workspaces" pathStr && lib.hasSuffix ".fish" pathStr)
    );
in
{
  options.${namespace}.wm.bspwm = {
    enable = mkEnableOption "Bspwm config using hm";

    monitors = {
      primary = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = "Primary monitor name (e.g., eDP-1). Auto-detected if null.";
        example = "eDP-1";
      };

      externalPosition = mkOption {
        type = types.enum [
          "left"
          "right"
        ];
        default = "left";
        description = "Position of external monitors relative to primary (affects workspace assignment).";
      };

      externalMaxResolution = mkOption {
        type = types.int;
        default = 4000;
        description = "Max width for external monitors. If exceeded, uses secondary resolution.";
      };
    };

    workspaces = {
      distribution = mkOption {
        type = types.enum [
          "split"
          "primary-all"
        ];
        default = "split";
        description = ''
          Workspace distribution strategy:
          - split: Left monitor gets 1-5,11-15; Right gets 6-10,16-20
          - primary-all: Primary gets 1-10; External gets 11-20
        '';
      };
    };
  };

  config = mkIf cfg.enable {
    home = {
      packages = with pkgs; [
        xorg.xrandr
      ];

      file = {
        # Copy static config files, excluding generated scripts
        ".config/bspwm" = {
          source = lib.cleanSourceWith {
            src = ./bspwm_config;
            filter = bspwmConfigFilter;
          };
          recursive = true;
        };

        # Generated monitor management script
        ".config/bspwm/scripts/monitor-management.fish" = {
          executable = true;
          text = monitorManagementScript;
        };
      };
    };
  };
}
