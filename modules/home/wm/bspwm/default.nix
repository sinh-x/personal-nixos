{
  # Snowfall Lib provides a customized `lib` instance with access to your flake's library
  # as well as the libraries available from your flake's inputs.
  lib,
  # An instance of `pkgs` with your overlays and packages applied is also available.
  pkgs,
  # You also have access to your flake's inputs.
  # All other arguments come from the module system.
  config,
  namespace,
  ...
}:
with lib;
let
  cfg = config.${namespace}.wm.bspwm;

  # Nix-interpolated values for scripts (use "auto" to indicate runtime detection)
  primaryMonitor = if cfg.monitors.primary != null then cfg.monitors.primary else "auto";
  inherit (cfg.monitors) externalPosition externalMaxResolution;
  inherit (cfg.workspaces) distribution;

  # Generated script: monitor-watcher.fish
  # Watches for monitor plug/unplug events and re-runs monitor management
  monitorWatcherScript = ''
    #!/usr/bin/env fish

    # Auto-generated by Nix - do not edit manually
    # Watches for X RandR events and triggers monitor reconfiguration

    set SCRIPT_DIR "$HOME/.config/bspwm/scripts"
    set LOG_FILE "$HOME/.config/bspwm/monitor-watcher.log"

    function log
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $argv" >> $LOG_FILE
    end

    log "Monitor watcher started"

    # Store current monitor state (initial setup already done by bspwmrc)
    set -g last_monitors (xrandr | grep " connected " | awk '{print $1}' | sort | string join ",")
    log "Initial monitors: $last_monitors"

    # Watch for monitor changes using xev (RandR events)
    # xev -root listens for root window events including RRScreenChangeNotify
    xev -root -event randr 2>/dev/null | while read -l line
        if string match -q "*RRScreenChangeNotify*" $line
            # Small delay to let the display settle
            sleep 1

            # Check if monitor list changed
            set current_monitors (xrandr | grep " connected " | awk '{print $1}' | sort | string join ",")

            if test "$current_monitors" != "$last_monitors"
                log "Monitor change detected: $last_monitors -> $current_monitors"
                set -g last_monitors $current_monitors

                # Re-run monitor management
                fish "$SCRIPT_DIR/monitor-management.fish"
                log "Monitor reconfiguration complete"

                # Restart polybar to update on new monitors
                if type -q bspbar
                    bspbar &
                    log "Polybar restarted"
                end

                # Send notification
                if type -q notify-send
                    notify-send "Monitor Changed" "Workspaces reconfigured for $current_monitors"
                end
            end
        end
    end
  '';

  # Generated script: monitor-management.fish
  monitorManagementScript = ''
    #!/usr/bin/env fish

    # Auto-generated by Nix - do not edit manually
    # Priority: User config file > Nix config > auto-detect

    # Nix-interpolated values
    set NIX_PRIMARY_MONITOR "${primaryMonitor}"
    set EXTERNAL_POSITION "${externalPosition}"
    set EXT_MAX_RES ${toString externalMaxResolution}
    set DISTRIBUTION "${distribution}"

    # Config file for per-monitor resolution preferences
    set CONFIG_FILE "$HOME/.config/bspwm/monitors.conf"

    # Load monitor preferences from config file
    # Format: MONITOR_NAME=WIDTHxHEIGHT@REFRESH or MONITOR_NAME=WIDTHxHEIGHT
    # Example:
    #   HDMI-1-0=2560x1600@130
    #   DP-1=3840x2160@60
    #   eDP-1=auto
    function get_preferred_resolution
        set monitor_name $argv[1]
        set default_res $argv[2]

        if test -f "$CONFIG_FILE"
            set config_line (grep "^$monitor_name=" "$CONFIG_FILE" 2>/dev/null | head -1)
            if test -n "$config_line"
                set preferred (echo $config_line | cut -d'=' -f2 | string trim)
                if test "$preferred" != "auto" -a -n "$preferred"
                    echo $preferred
                    return
                end
            end
        end

        echo $default_res
    end

    # Parse resolution string (WIDTHxHEIGHT or WIDTHxHEIGHT@REFRESH)
    function parse_resolution
        set res_string $argv[1]
        # Extract just WIDTHxHEIGHT part (before @ if present)
        echo $res_string | cut -d'@' -f1
    end

    # Get refresh rate from resolution string (or empty if not specified)
    function parse_refresh_rate
        set res_string $argv[1]
        if string match -q "*@*" $res_string
            echo $res_string | cut -d'@' -f2
        end
    end

    # Resolve primary monitor: Nix config > auto-detect
    if test "$NIX_PRIMARY_MONITOR" != "auto"
        set INTERNAL_MONITOR "$NIX_PRIMARY_MONITOR"
    else
        # Auto-detect first connected monitor (usually internal)
        set INTERNAL_MONITOR (xrandr | grep " connected " | head -1 | awk '{print $1}')
    end

    # Main monitor position (left or right side of the display setup)
    set main_monitor_post $EXTERNAL_POSITION

    function set_display
        # Get the output of xrandr and split it into lines
        set output (xrandr | string split '\n')
        set index 0
        set connected_indices
        set disconnected_indices

        # Loop over the lines
        for line in $output
            set index (math $index+1)
            if string match -q "* connected *" $line
                set connected_indices $connected_indices $index
            else if string match -q "* disconnected *" $line
                set disconnected_indices $disconnected_indices $index
            end
        end

        set connected_monitors
        set resolutions
        set refresh_rates

        # Loop over the indices of connected monitors to get their name & resolution
        for idx in $connected_indices
            set monitor_name (echo $output[$idx] | awk '{print $1}')
            set resolution_idx (math $idx+1)
            set default_res (echo $output[$resolution_idx] | awk '{print $1}')
            set width (echo $default_res | awk -F x '{print $1}')

            # If external monitor width exceeds max, use secondary resolution
            if test "$monitor_name" != "$INTERNAL_MONITOR" -a $width -gt $EXT_MAX_RES
                set resolution_idx (math $resolution_idx+1)
                set default_res (echo $output[$resolution_idx] | awk '{print $1}')
            end

            # Check for user-configured preferred resolution
            set preferred (get_preferred_resolution $monitor_name $default_res)
            set res (parse_resolution $preferred)
            set rate (parse_refresh_rate $preferred)

            set connected_monitors $connected_monitors $monitor_name
            set resolutions $resolutions $res
            set refresh_rates $refresh_rates $rate
        end

        # Turn off disconnected monitors
        for idx in $disconnected_indices
            set monitor_name (echo $output[$idx] | awk '{print $1}')
            xrandr --output $monitor_name --off 2>/dev/null
        end

        # Configure connected monitors with proper positioning
        set y 0
        set cur_x 0
        for i in (seq (count $connected_monitors))
            set xrandr_cmd "xrandr --output $connected_monitors[$i] --mode $resolutions[$i] --pos {$cur_x}x{$y}"

            # Add refresh rate if specified
            if test -n "$refresh_rates[$i]"
                set xrandr_cmd "$xrandr_cmd --rate $refresh_rates[$i]"
            end

            # Execute xrandr command
            eval $xrandr_cmd

            # Calculate x-coordinate for next monitor based on position preference
            if test "$main_monitor_post" = "left"
                set x_add (echo $resolutions[$i] | awk -F x '{print $1}')
                set cur_x (math $cur_x+$x_add)
            else
                set x_add (echo $resolutions[$i] | awk -F x '{print $1}')
                set cur_x (math $cur_x-$x_add)
            end
        end
    end

    function default_workspace
        # Single monitor: assign workspaces 1-10
        bspc monitor $INTERNAL_MONITOR -d 1 2 3 4 5 6 7 8 9 10
    end

    function two_monitors_workspace
        # Dual monitor workspace assignment based on distribution strategy
        for monitor in (bspc query -M --names)
            # Get the coordinates of the monitor
            set coordinate (xrandr | grep $monitor | grep -oP '\d+x\d+\+\d+\+\d+')
            set x_coordinate (echo $coordinate | awk -F '[x+]' '{print $3}')

            if test -n "$x_coordinate"
                set x_coordinate (math $x_coordinate)

                if test "$DISTRIBUTION" = "split"
                    # Split distribution: Left gets 1-5,11-15; Right gets 6-10,16-20
                    if test $x_coordinate -eq 0
                        bspc monitor $monitor -d 1 2 3 4 5 11 12 13 14 15
                    else
                        bspc monitor $monitor -d 6 7 8 9 10 16 17 18 19 20
                    end
                else
                    # primary-all distribution: Primary gets 1-10; External gets 11-20
                    if test "$monitor" = "$INTERNAL_MONITOR"
                        bspc monitor $monitor -d 1 2 3 4 5 6 7 8 9 10
                    else
                        bspc monitor $monitor -d 11 12 13 14 15 16 17 18 19 20
                    end
                end
            end
        end
    end

    # Configure displays
    set_display

    # Get the number of connected monitors
    set monitors_count (xrandr | grep -c " connected ")

    # Assign workspaces based on monitor count
    if test $monitors_count -eq 1
        default_workspace
    else
        two_monitors_workspace
    end
  '';

  # Filter to exclude the generated scripts from static copy
  bspwmConfigFilter =
    path: _:
    let
      baseName = baseNameOf path;
      pathStr = toString path;
    in
    !(
      # Exclude generated monitor scripts
      baseName == "monitor-management.fish"
      || baseName == "monitor-watcher.fish"
      # Exclude host-specific monitor scripts (now generated)
      || (lib.hasInfix "monitors-workspaces" pathStr && lib.hasSuffix ".fish" pathStr)
    );
in
{
  options.${namespace}.wm.bspwm = {
    enable = mkEnableOption "Bspwm config using hm";

    monitors = {
      primary = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = "Primary monitor name (e.g., eDP-1). Auto-detected if null.";
        example = "eDP-1";
      };

      externalPosition = mkOption {
        type = types.enum [
          "left"
          "right"
        ];
        default = "left";
        description = "Position of external monitors relative to primary (affects workspace assignment).";
      };

      externalMaxResolution = mkOption {
        type = types.int;
        default = 4000;
        description = "Max width for external monitors. If exceeded, uses secondary resolution.";
      };
    };

    workspaces = {
      distribution = mkOption {
        type = types.enum [
          "split"
          "primary-all"
        ];
        default = "split";
        description = ''
          Workspace distribution strategy:
          - split: Left monitor gets 1-5,11-15; Right gets 6-10,16-20
          - primary-all: Primary gets 1-10; External gets 11-20
        '';
      };
    };
  };

  config = mkIf cfg.enable {
    home = {
      packages = with pkgs; [
        xorg.xrandr
        xorg.xev # For monitoring RandR events
      ];

      file = {
        # Copy static config files, excluding generated scripts
        ".config/bspwm" = {
          source = lib.cleanSourceWith {
            src = ./bspwm_config;
            filter = bspwmConfigFilter;
          };
          recursive = true;
        };

        # Generated monitor management script
        ".config/bspwm/scripts/monitor-management.fish" = {
          executable = true;
          text = monitorManagementScript;
        };

        # Generated monitor watcher script (auto-detects plug/unplug)
        ".config/bspwm/scripts/monitor-watcher.fish" = {
          executable = true;
          text = monitorWatcherScript;
        };
      };
    };
  };
}
